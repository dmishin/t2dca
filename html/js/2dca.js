// Generated by CoffeeScript 1.7.1
(function() {
  var $container, ASPECT, FAR, HEIGHT, NEAR, RuleSelector, VIEW_ANGLE, WIDTH, animationStop, areRulesCompatible, camera, cellGeometry, cellMaterial, closeSettings, controls, createAxes, createWorldEvolutionMesh, createWorldMesh, cubeSize, getCanvasCursorPosition, initScene, initialPattern, makeTextureSprite, maxTime, onWindowResize, putCamLight, putPatternAtCenter, renderer, rulePair, scene, sceneObjects, showSettings, simulationTime, skyBox, skyBoxGeometry, skyBoxMaterial, spriteTextures, update, updateWorld, wolfram_automata;

  WIDTH = window.innerWidth - 10;

  HEIGHT = window.innerHeight - 10;

  VIEW_ANGLE = 45;

  ASPECT = WIDTH / HEIGHT;

  NEAR = 0.1;

  FAR = 10000;

  rulePair = [150, 60];

  simulationTime = 15;

  maxTime = 40;

  sceneObjects = null;

  initialPattern = "#";

  animationStop = false;

  $container = document.getElementById("container");

  renderer = Detector.webgl ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer();

  camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

  scene = new THREE.Scene();

  wolfram_automata = {
    30: 1,
    50: 1,
    54: 1,
    60: 1,
    62: 1,
    90: 1,
    94: 1,
    102: 1,
    110: 1,
    126: 1,
    150: 1,
    158: 1,
    182: 1,
    188: 1,
    190: 1,
    220: 1,
    222: 1
  };

  scene.add(camera);

  camera.position.set(-14, -40, -60);

  camera.lookAt(scene);

  controls = null;

  renderer.setSize(WIDTH, HEIGHT);

  $container.appendChild(renderer.domElement);

  cellMaterial = [
    new THREE.MeshLambertMaterial({
      color: 0x9eff5f
    }), new THREE.MeshLambertMaterial({
      color: 0xf68241
    }), new THREE.MeshLambertMaterial({
      color: 0x5facff
    }), new THREE.MeshLambertMaterial({
      color: 0xeaeaea
    })
  ];

  cubeSize = 1.0;

  cellGeometry = new THREE.CubeGeometry(cubeSize, cubeSize, cubeSize);

  createWorldMesh = function(worldState) {
    var cell, i, stringGeometry, wi, _i, _len;
    stringGeometry = new THREE.Geometry();
    for (i = _i = 0, _len = worldState.length; _i < _len; i = ++_i) {
      wi = worldState[i];
      if (!wi) {
        continue;
      }
      cell = new THREE.Mesh(cellGeometry);
      cell.position.x = i - worldState.length * 0.5;
      THREE.GeometryUtils.merge(stringGeometry, cell);
    }
    return stringGeometry;
  };

  putCamLight = function(color, intens, x, y, z) {
    var pointLight;
    pointLight = new THREE.PointLight(color, intens);
    pointLight.position.set(x, y, z);
    return scene.add(pointLight);
  };


  /*
    geom = new THREE.SphereGeometry 0.5, 6, 6
    mesh = new THREE.Mesh geom, new THREE.MeshLambertMaterial(color: color)
    mesh.position.set x,y,z
    scene.add mesh
   */

  putCamLight(0xf0fff0, 0.7, -60, 60, -30);

  putCamLight(0xf0f0ff, 0.7, 60, 60, -30);

  putCamLight(0xfff0f0, 0.7, 0, -28, -30);

  putCamLight(0xffeeee, 0.2, 0, 0, 90);

  putCamLight(0xffffff, 0.2, 0, 0, 0);

  skyBoxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);

  spriteTextures = {
    t1: THREE.ImageUtils.loadTexture('./images/sprite-t1.png'),
    t2: THREE.ImageUtils.loadTexture('./images/sprite-t2.png'),
    x: THREE.ImageUtils.loadTexture('./images/sprite-x.png')
  };

  skyBoxMaterial = new THREE.MeshBasicMaterial({
    color: 0x333333,
    side: THREE.BackSide
  });

  skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);

  scene.add(skyBox);

  update = function() {
    if (animationStop) {
      animationStop = false;
      return;
    }
    controls.update();
    renderer.render(scene, camera);
    return requestAnimationFrame(update);
  };

  createAxes = function(len) {
    var arrow, axes, makeArrow, pointerMaterial, stemMaterial, stemRadius;
    stemMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFFFF
    });
    pointerMaterial = new THREE.MeshBasicMaterial({
      color: 0x00FF00
    });
    stemRadius = 0.05;
    makeArrow = function(len, label) {
      var lbl, pointer, pointerG, stem, stemG;
      stemG = new THREE.CylinderGeometry(stemRadius, stemRadius, len, 4, 1);
      stemG.applyMatrix((new THREE.Matrix4()).makeTranslation(0, len / 2, 0));
      pointerG = new THREE.CylinderGeometry(0, stemRadius * 4, 1, 32, 2);
      stem = new THREE.Mesh(stemG, stemMaterial);
      pointer = new THREE.Mesh(pointerG, pointerMaterial);
      pointer.position.y = len;
      stem.add(pointer);
      lbl = makeTextureSprite(spriteTextures[label]);
      lbl.position.set(0, len + 2, 0);
      lbl.scale.set(2, 2, 2);
      stem.add(lbl);
      return stem;
    };
    axes = new THREE.Object3D();
    arrow = makeArrow(len, 't1');
    arrow.rotation.x = 0;
    axes.add(arrow);
    arrow = makeArrow(len, "t2");
    arrow.rotation.x = Math.PI / 2;
    axes.add(arrow);
    arrow = makeArrow(len * 2, "x");
    arrow.position.x = len;
    arrow.rotation.z = Math.PI / 2;
    axes.add(arrow);
    axes.position.set(-0.5, -1, -1);
    return axes;
  };

  createWorldEvolutionMesh = function(world, index1, index2, time) {
    var automaton, automaton2, g, geomIdx, i, stringMesh, t, t1, w, worldGeometry, worldObj, wt, _i, _j, _k, _len;
    worldGeometry = [new THREE.Geometry(), new THREE.Geometry(), new THREE.Geometry(), new THREE.Geometry()];
    automaton = index2table(index1);
    automaton2 = index2table(index2);
    w = world;
    for (t = _i = 0; _i < time; t = _i += 1) {
      wt = w;
      for (t1 = _j = 0; _j < time; t1 = _j += 1) {
        geomIdx = (t > 0) * 1 + (t1 > 0) * 2;
        stringMesh = new THREE.Mesh(createWorldMesh(wt));
        stringMesh.position.set(0, t, t1);
        THREE.GeometryUtils.merge(worldGeometry[geomIdx], stringMesh);
        wt = tfm_circular(wt, automaton2);
      }
      w = tfm_circular(w, automaton);
    }
    worldObj = new THREE.Object3D();
    for (i = _k = 0, _len = worldGeometry.length; _k < _len; i = ++_k) {
      g = worldGeometry[i];
      worldObj.add(new THREE.Mesh(g, cellMaterial[i]));
    }
    return worldObj;
  };

  makeTextureSprite = function(texture) {
    var sprite, spriteMaterial;
    spriteMaterial = new THREE.SpriteMaterial({
      map: texture,
      useScreenCoordinates: false
    });
    sprite = new THREE.Sprite(spriteMaterial);
    return sprite;
  };

  showSettings = function() {
    var container;
    container = document.getElementById("settings");
    container.style.display = "block";
    animationStop = true;
    return document.getElementById("simulation-time").value = simulationTime;
  };

  closeSettings = function() {
    var container, t;
    container = document.getElementById("settings");
    container.style.display = "none";
    t = parseInt(document.getElementById("simulation-time").value, 10);
    if (!isNaN(t)) {
      simulationTime = Math.min(maxTime, Math.max(1, t));
    }
    updateWorld();
    return update();
  };

  updateWorld = function() {
    var time, world, _;
    world = (function() {
      var _i, _ref, _results;
      _results = [];
      for (_ = _i = 0, _ref = simulationTime * 4 + initialPattern.length; 0 <= _ref ? _i < _ref : _i > _ref; _ = 0 <= _ref ? ++_i : --_i) {
        _results.push(0);
      }
      return _results;
    })();
    putPatternAtCenter(world, initialPattern);
    time = simulationTime;
    if (sceneObjects !== null) {
      scene.remove(sceneObjects);
    }
    sceneObjects = new THREE.Object3D();
    sceneObjects.add(createWorldEvolutionMesh(world, rulePair[0], rulePair[1], time, time));
    sceneObjects.add(createAxes(time + 3));
    sceneObjects.position.set(-time * 0.5, -time * 0.5, -time * 0.5);
    scene.add(sceneObjects);
    return sceneObjects;
  };

  window.initApplication = function() {
    var patternEdit, rule1Selector, rule2Selector;
    document.getElementById("show-settings").onclick = function() {
      return showSettings();
    };
    document.getElementById("settings").onclick = function() {
      return closeSettings();
    };
    document.getElementById("close-settings").onclick = function() {
      return closeSettings();
    };
    document.getElementById("settings-inner").onclick = function(e) {
      return e.stopPropagation();
    };
    patternEdit = document.getElementById("initial-pattern-text");
    patternEdit.value = initialPattern;
    window.addEventListener('resize', onWindowResize, false);
    rule1Selector = new RuleSelector("rule1-select-graph", "rule1-diagram", "rule1-text", "rule1-info", rulePair[0]);
    rule2Selector = new RuleSelector("rule2-select-graph", "rule2-diagram", "rule2-text", "rule2-info", rulePair[1], rulePair[0]);
    patternEdit.onchange = function(e) {
      var newPattern;
      newPattern = patternEdit.value;
      initialPattern = newPattern;
      rule1Selector.drawEvolution();
      return rule2Selector.drawEvolution();
    };
    rule2Selector.onrule = function(rule) {
      return rulePair[1] = rule;
    };
    rule1Selector.onrule = function(rule) {
      rulePair[0] = rule;
      return rule2Selector.setCompatibileWith(rule);
    };
    return initScene();
  };

  putPatternAtCenter = function(world, pattern) {
    var i, patternCenter, worldCenter, _i, _ref, _results;
    worldCenter = world.length / 2 | 0;
    patternCenter = pattern.length / 2 | 0;
    _results = [];
    for (i = _i = 0, _ref = pattern.length; _i < _ref; i = _i += 1) {
      if (pattern.charAt(i) === '#') {
        _results.push(world[i - patternCenter + worldCenter] = 1);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  RuleSelector = (function() {
    function RuleSelector(diagramId, displayId, textFieldId, infoFieldId, selectedRule, compatibleWith) {
      var displayCanvas;
      this.selectedRule = selectedRule != null ? selectedRule : 0;
      this.compatibleWith = compatibleWith != null ? compatibleWith : null;
      this.iconSize = 8;
      this.diagramCanvas = document.getElementById(diagramId);
      this.diagramContext = this.diagramCanvas.getContext("2d");
      displayCanvas = document.getElementById(displayId);
      this.displayContext = displayCanvas.getContext("2d");
      this.textField = document.getElementById(textFieldId);
      this.infoField = document.getElementById(infoFieldId);
      this.textField.value = this.selectedRule;
      this.diagramCanvas.onclick = (function(_this) {
        return function(event) {
          return _this.onCanvasClick(event);
        };
      })(this);
      this.draw();
      this.drawEvolution();
      this.textField.onchange = (function(_this) {
        return function(e) {
          var newVal;
          newVal = parseInt(_this.textField.value, 10);
          if (newVal >= 0 && newVal <= 255 && (newVal % 2 === 0)) {
            if (_this.acceptRule(newVal)) {
              return _this.setSelected(newVal);
            } else {
              return _this.showErrorMessage("Rule " + newVal + " is not compatible with the first rule");
            }
          } else {
            return _this.showErrorMessage("Rule code must be even number in range [0 .. 254]");
          }
        };
      })(this);
    }

    RuleSelector.prototype.showWolfrawmUrl = function() {
      var atag;
      this.infoField.innerHTML = "";
      atag = document.createElement("a");
      atag.setAttribute("href", "http://mathworld.wolfram.com/Rule" + this.selectedRule + ".html");
      atag.setAttribute("target", "_blanc");
      atag.appendChild(document.createTextNode("Rule" + this.selectedRule));
      this.infoField.appendChild(document.createTextNode("Wolfram: "));
      this.infoField.appendChild(atag);
      return this.infoField.style.display = "block";
    };

    RuleSelector.prototype.showErrorMessage = function(msg) {
      var span;
      this.infoField.innerHTML = "";
      span = document.createElement("span");
      span.setAttribute("class", "error-text");
      span.appendChild(document.createTextNode(msg));
      this.infoField.appendChild(span);
      return this.infoField.style.display = "block";
    };

    RuleSelector.prototype.hideInfo = function() {
      this.infoField.innerHTML = "";
      return this.infoField.style.display = "hidden";
    };

    RuleSelector.prototype.setSelected = function(newRule) {
      if (newRule !== this.selectedRule) {
        this.selectedRule = newRule;
        this.clearDiagram();
        this.draw();
        this.drawEvolution();
        this.onrule(newRule);
        if (wolfram_automata[newRule]) {
          return this.showWolfrawmUrl();
        } else {
          return this.hideInfo();
        }
      }
    };

    RuleSelector.prototype.acceptRule = function(rule) {
      if (this.compatibleWith === null) {
        return true;
      } else {
        return areRulesCompatible(this.compatibleWith, rule);
      }
    };

    RuleSelector.prototype.draw = function() {
      var ctx, iconSize, idx, x, xsel, y, ysel, _i, _j;
      ctx = this.diagramContext;
      iconSize = this.iconSize;
      xsel = null;
      for (y = _i = 0; _i < 8; y = ++_i) {
        for (x = _j = 0; _j < 16; x = ++_j) {
          idx = this.cell2rule(x, y);
          if (idx === this.selectedRule) {
            xsel = x;
            ysel = y;
          }
          if (this.acceptRule(idx)) {
            this.drawRuleIcon(ctx, idx, x * iconSize, y * iconSize, iconSize);
          }
        }
      }
      if (xsel !== null) {
        ctx.strokeStyle = "#ff0000";
        ctx.strokeRect(xsel * iconSize - .5, ysel * iconSize - .5, iconSize + 1, iconSize + 1);
      }
    };

    RuleSelector.prototype.drawEvolution = function() {
      var automaton, ctx, size, steps, wi, world, x, y, _, _i, _len;
      ctx = this.displayContext;
      size = 2;
      steps = 32;
      world = (function() {
        var _i, _results;
        _results = [];
        for (_ = _i = 0; _i < 64; _ = ++_i) {
          _results.push(0);
        }
        return _results;
      })();
      automaton = index2table(this.selectedRule);
      putPatternAtCenter(world, initialPattern);
      ctx.clearRect(0, 0, world.length * size, steps * size);
      ctx.fillStyle = "black";
      y = 0;
      while (true) {
        for (x = _i = 0, _len = world.length; _i < _len; x = ++_i) {
          wi = world[x];
          if (wi !== 0) {
            ctx.fillRect(x * size, y * size, size, size);
          }
        }
        y++;
        if (y >= 32) {
          break;
        }
        world = tfm_circular(world, automaton);
      }
    };

    RuleSelector.prototype.cell2rule = function(ix, iy) {
      return ix * 16 + iy * 2;
    };

    RuleSelector.prototype.drawShadedRuleIcon = function(ctx, rule, x, y, size) {
      ctx.fillStyle = "gray";
      return ctx.fillRect(x, y, size, size);
    };

    RuleSelector.prototype.colors = [new THREE.Color(0x00a1ff), new THREE.Color(0x1f2f1f)];

    RuleSelector.prototype.numDuals2Color = function(nduals) {
      var clr, cs, t;
      t = (nduals - 3) / (15 - 3);
      t = Math.min(Math.max(0.0, t), 1.0);
      cs = this.colors;
      clr = cs[1].clone().lerp(cs[0], t);
      return "#" + clr.getHexString();
    };

    RuleSelector.prototype.drawRuleIcon = function(ctx, rule, x, y, size) {
      var hasFlag, mirror, props;
      props = RULE_PROPERTIES[rule.toString(16)];
      hasFlag = function(propChar) {
        return props.flags.indexOf(propChar) !== -1;
      };
      mirror = parseInt(props.mirror, 16);
      ctx.fillStyle = this.numDuals2Color(parseInt(props.nduals, 16));
      ctx.fillRect(x, y, size, size);
      ctx.strokeStyle = mirror < rule ? "white" : "yellow";
      if (hasFlag("|")) {
        ctx.beginPath();
        ctx.moveTo(x + 1, y + size - 1);
        ctx.lineTo(x + size * 0.5, y + 1);
        ctx.lineTo(x + size - 1, y + size - 1);
        ctx.stroke();
      }
      if (hasFlag("&")) {
        ctx.beginPath();
        ctx.moveTo(x + 1, y + 1);
        ctx.lineTo(x + size * 0.5, y + size - 1);
        ctx.lineTo(x + size - 1, y + 1);
        ctx.stroke();
      }
      if (hasFlag("^")) {
        ctx.beginPath();
        ctx.moveTo(x + 1, y + size * 0.5);
        ctx.lineTo(x + size - 1, y + size * 0.5);
        ctx.moveTo(x + size * 0.5, y + 1);
        ctx.lineTo(x + size * 0.5, y + size - 1);
        ctx.stroke();
      }
      if (wolfram_automata[rule]) {
        ctx.strokeStyle = "green";
        ctx.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);
      }
    };

    RuleSelector.prototype.onCanvasClick = function(event) {
      var ix, iy, rule, x, y, _ref;
      _ref = getCanvasCursorPosition(event, this.diagramCanvas), x = _ref[0], y = _ref[1];
      ix = (x / this.iconSize) | 0;
      iy = (y / this.iconSize) | 0;
      if (!(ix < 0 || ix >= 16 || iy < 0 || iy >= 8)) {
        event.preventDefault();
        rule = this.cell2rule(ix, iy);
        if (!this.acceptRule(rule)) {
          return;
        }
        this.setSelected(rule);
        return this.textField.value = rule;
      }
    };

    RuleSelector.prototype.setCompatibileWith = function(rule) {
      this.compatibleWith = rule;
      this.clearDiagram();
      return this.draw();
    };

    RuleSelector.prototype.clearDiagram = function() {
      return this.diagramContext.clearRect(0, 0, 16 * this.iconSize, 8 * this.iconSize);
    };

    RuleSelector.prototype.onrule = function(rule) {};

    return RuleSelector;

  })();

  initScene = function() {
    updateWorld();
    if (true) {
      controls = new THREE.TrackballControls(camera, renderer.domElement);
      controls.rotateSpeed = 2.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.noZoom = false;
      controls.noPan = false;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;
      controls.keys = [65, 83, 68];
    }
    return update();
  };

  onWindowResize = function() {
    WIDTH = window.innerWidth - 10;
    HEIGHT = window.innerHeight - 10;
    camera.aspect = WIDTH / HEIGHT;
    camera.updateProjectionMatrix();
    renderer.setSize(WIDTH, HEIGHT);
    controls.handleResize();
    return render();
  };

  areRulesCompatible = function(rule1, rule2) {
    var map;
    if (rule2 < rule1) {
      return areRulesCompatible(rule2, rule1);
    } else if (rule2 === rule1) {
      return true;
    } else {
      if ((map = RULES_COMPATIBILITY_MAP[rule1.toString(16)]) != null) {
        return (rule2.toString(16)) in map;
      } else {
        return false;
      }
    }
  };

  getCanvasCursorPosition = function(e, canvas) {
    var rect;
    if (e.type === "touchmove" || e.type === "touchstart" || e.type === "touchend") {
      e = e.touches[0];
    }
    if (e.clientX != null) {
      rect = canvas.getBoundingClientRect();
      return [e.clientX - rect.left, e.clientY - rect.top];
    }
  };

}).call(this);

//# sourceMappingURL=2dca.map
